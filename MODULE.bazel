###############################################################################
# Bazel now uses Bzlmod by default to manage external dependencies.
# Please consider migrating your external dependencies from WORKSPACE to MODULE.bazel.
#
# For more details, please check https://github.com/bazelbuild/bazel/issues/18958
###############################################################################

module(
    name = "pybind_plot",
    version = "0.0.1",
)

###############################################################################
# Bazel Enhancers
###############################################################################

bazel_dep(name = "bazel_skylib", version = "1.7.1")

bazel_dep(
    name = "buildifier_prebuilt",
    version = "6.4.0",
    dev_dependency = True,
)

###############################################################################
# Python dependencies
###############################################################################

# Update the version "0.0.0" to the release found here:
# https://github.com/bazelbuild/rules_python/releases.
bazel_dep(name = "rules_python", version = "0.33.2")

# The following stanze returns a proxy object representing a module extension;
# its methods can be invoked to create module extension tags.
python = use_extension("@rules_python//python/extensions:python.bzl", "python")

# We next initialize the python toolchain using the extension.
# You can set different Python versions in this block.
python.toolchain(
    configure_coverage_tool = True,
    is_default = True,
    python_version = "3.9",
)

# You only need to load this repositories if you are using multiple Python versions.
# See the tests folder for various examples on using multiple Python versions.
# The names "python_3_9" and "python_3_10" are autmatically created by the repo
# rules based on the `python_version` arg values.
use_repo(python, python_3_9 = "python_3_9")

# Use the extension, pip.parse, to call the `pip_repository` rule that invokes
# `pip`, with `incremental` set. The pip call accepts a locked/compiled
# requirements file and installs the dependencies listed within.
# Those dependencies become available in a generated `requirements.bzl` file.
# You can instead check this `requirements.bzl` file into your repo.
# Because this project has different requirements for windows vs other
# operating systems, we have requirements for each.
pip = use_extension("@rules_python//python/extensions:pip.bzl", "pip")
pip.parse(
    hub_name = "pypi",
    #    python_interpreter_target = "@python_3_9//:python",
    # The interpreter_target attribute points to the interpreter to
    # use for running pip commands to download the packages in the
    # requirements file.
    # As a best practice, we use the same interpreter as the toolchain
    # that was configured above; this ensures the same Python version
    # is used for both resolving dependencies and running tests/binaries.
    # If this isn't specified, then you'll get whatever is locally installed
    # on your system.
    python_version = "3.9",
    requirements_lock = "//:requirements_lock.txt",
    requirements_windows = "//:requirements_windows.txt",
)

# Imports the pip toolchain generated by the given module extension into the scope of the current module.
use_repo(pip, "pypi")

bazel_dep(name = "pybind11_bazel", version = "2.12.0")
